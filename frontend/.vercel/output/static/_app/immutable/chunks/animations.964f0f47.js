function y(e){return e()}function k(e){e.forEach(y)}const o=[],p=[],r=[],v=[],b=Promise.resolve();let f=!1;function O(){f||(f=!0,b.then(I))}function C(){return O(),b}function E(e){r.push(e)}const d=new Set;let c=0;function I(){do{for(;c<o.length;){const e=o[c];c++,R(e.$$)}for(o.length=0,c=0;p.length;)p.pop()();for(let e=0;e<r.length;e+=1){const t=r[e];d.has(t)||(d.add(t),t())}r.length=0}while(o.length);for(;v.length;)v.pop()();f=!1,d.clear()}function R(e){if(e.fragment!==null){e.update(),k(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(E)}}const z={root:null,rootMargin:"0px",threshold:0,unobserveOnEnter:!1},s=(e,t)=>new CustomEvent(e,{detail:t});function j(e,t={}){const{root:g,rootMargin:_,threshold:w,unobserveOnEnter:m}=Object.assign(Object.assign({},z),t);let l={x:void 0,y:void 0},i={vertical:void 0,horizontal:void 0};if(typeof IntersectionObserver<"u"&&e){const a=new IntersectionObserver((x,h)=>{x.forEach(n=>{l.y>n.boundingClientRect.y?i.vertical="up":i.vertical="down",l.x>n.boundingClientRect.x?i.horizontal="left":i.horizontal="right",l={y:n.boundingClientRect.y,x:n.boundingClientRect.x};const u={inView:n.isIntersecting,entry:n,scrollDirection:i,node:e,observer:h};e.dispatchEvent(s("change",u)),n.isIntersecting?(e.dispatchEvent(s("enter",u)),m&&h.unobserve(e)):e.dispatchEvent(s("leave",u))})},{root:g,rootMargin:_,threshold:w});return C().then(()=>{e.dispatchEvent(s("init",{observer:a,node:e}))}),a.observe(e),{destroy(){a.unobserve(e)}}}}export{j as i};
